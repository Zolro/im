<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Socket</title>
    <script type="text/javascript" src="/wangEditor-3.1.1/release/wangEditor.min.js"></script>
    <script type="text/javascript" src="/js/bundle.js"></script>
    <script type="text/javascript" src="/js/jquery-3.2.1.js"></script>
    <script type="text/javascript">
        function getQueryVariable(variable) {
            var query = window.location.search.substring(1);
            var vars = query.split("&");
            for (var i = 0; i < vars.length; i++) {
                var pair = vars[i].split("=");
                if (pair[0] == variable) {
                    return pair[1];
                }
            }
            return (false);
        }

        var userpkey = getQueryVariable("UserInfo");
        var lockReconnect = false;  //避免ws重复连接
        var ws = null;          // 判断当前浏览器是否支持WebSocket
        var wsUrl = "ws://192.168.40.31:8080/websocket/10" ;
        createWebSocket(wsUrl);

        function createWebSocket(url) {
            try {
                if ('WebSocket' in window) {
                    ws = new WebSocket(url);
                } else if ('MozWebSocket' in window) {
                    ws = new MozWebSocket(url);
                } else {
                    alert("您的浏览器不支持websocket协议,建议使用新版谷歌、火狐等浏览器，请勿使用IE10以下浏览器，360浏览器请使用极速模式，不要使用兼容模式！");
                }
                initEventHandle();
            } catch (e) {
                reconnect(url);
                console.log(e);
            }
        }

        /////////////////////////////////////
        function initEventHandle() {
            ws.onclose = function (event) {
                console.log("连接关闭!" + new Date().toUTCString());
                console.log(event)
                $("#msg").append("<div>断开连接</div>")
            };
            ws.onerror = function (event) {
                console.log(event)
                console.log("连接错误!");
                reconnect(wsUrl);
            };
            ws.onopen = function () {
                //  heartCheck.reset().start();      //心跳检测重置
                console.log("连接成功!" + new Date().toUTCString());
                //      ws.send(message.serializeBinary());
                $("#msg").append("<div>建立连接</div>")
            };
            ws.onmessage = function (event) {    //如果获取到消息，心跳检测重置
                var data = JSON.parse(event.data)
                console.log("消息")
                console.log(data)
                if (data["msgtype"] == 1 && data["cmd"] == 6) {  // 加载页面用户信息 和好友列表信息
                    var content = JSON.parse(data.content)
                    if(data.url=="init"){
                        console.log(" 加载页面用户信息 和好友列表信息")
                        var initdata=publicResulthandle(content)
                        datainfo=initdata  //存储给公共的用户信息
                        if(initdata){
                            loadfriendlist(initdata)
                        }
                    }

                    if(data.url=="findUseridRecordCustom"){
                        console.log(" 加载用户好友聊天列表")
                        var findUseridRecordCustom=publicResulthandle(content)
                        if(findUseridRecordCustom){
                            findUseridRecordCustomlist(findUseridRecordCustom)
                        }
                    }
                    if(data.url=="getuserlist"){
                        console.log(" 加载查询的用户列表")
                        var getuserlist=publicResulthandle(content)
                        if(getuserlist){
                            onfindmsglistResult(getuserlist)
                        }
                    }
                    if(data.url=="getfriedns"){
                        console.log(" 申请好友 进入申请列表")
                        console.log(content)
                        var getuserlist=publicResulthandlevoid(content)
                    }
                    if(data.url=="getapplyfriendlist"){
                        console.log(" 好友申请列表")
                        var getuserlist=publicResulthandle(content)
                        console.log(getuserlist)
                        if(getuserlist){
                            getapplyfriendResult(getuserlist)
                        }
                    }
                    if(data.url=="updApplyUser"){
                        console.log(" 修改申请好友信息")
                        var updApplyUserinfo=publicResulthandle(content)
                        if(updApplyUserinfo){
                            getapplyfriend()
                            loaduserinfo()
                        }
                    }
                    if(data.url=="findUserRead"){
                        var findUserReadinfo=publicResulthandle(content)
                        if(findUserReadinfo){
                            console.log(" 查询对应所选中的好友 对应未阅读的剩余信息finduserstateResult")
                            finduserstateResult(findUserReadinfo)
                        }
                    }


                }

                if (data["msgtype"] == 1 && data["cmd"] == 4) {
                    var content = JSON.parse(data.content)
                    console.log(content)
                    //     heartCheck.reset().start();      //拿到任何消息都说明当前连接是正常的
                    $("#msg").append("<div> 消息内容:" + content.content + ">>发送时间:" + content.created + "拥有者id:" + content.fromId + "</div>")
                } else if (data["msgtype"] == 0 && data["cmd"] == 4) {
                    var content = JSON.parse(data.content)
                    $("#msg").append("<div> 推送消息内容:" + content.content + ">>发送时间:" + content.created + "来自id:" + content.fromId + "</div>")
                }
                // var message=proto.Model.deserializeBinary(event.data);
                // console.log("收到消息啦:"+message);
                // if(message.getCmd()==2&&message.getMsgtype()==1){
                //     console.log("接收到后端--->>发送给前端》》》》》》心跳信息")
                //     var message = new proto.Model();
                //     message.setCmd(2)
                //     message.setMsgtype(2)
                //     ws.send(message.serializeBinary());
                //     console.log("返回给后端接收到信息")
                // }else if(message.getCmd()==2&&message.getMsgtype()==2){
                //     console.log("接收到前端--->>发送给后端》》》》》返回心跳信息")
                // }
            };
        }

        // 监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。
        window.onbeforeunload = function () {
            console.log("网页关闭时，关闭窗口")
            ws.close();
        }

        function reconnect(url) {
            if (lockReconnect) return;
            lockReconnect = true;
            setTimeout(function () {     //没连接上会一直重连，设置延迟避免请求过多
                createWebSocket(url);
                lockReconnect = false;
            }, 2000);
        }

        //  心跳检测
        var heartCheck = {
            //timeout: 540000,        //9分钟发一次心跳
            //timeout: 3600,        //1分钟发一次心跳
            timeout: 108000,        //3分钟发一次心跳
            timeoutObj: null,
            serverTimeoutObj: null,
            reset: function () {
                clearTimeout(this.timeoutObj);
                clearTimeout(this.serverTimeoutObj);
                return this;
            },
            start: function () {
                var self = this;
                this.timeoutObj = setTimeout(function () {
                    console.log("发送心跳检测")
                    var message = new proto.Model();
                    message.setCmd(2)
                    message.setMsgtype(1)
                    ws.send(message.serializeBinary());
                    self.serverTimeoutObj = setTimeout(function () {
                        //如果超过一定时间还没重置，说明后端主动断开了
                        //如果onclose会执行reconnect，我们执行ws.close()就行了.如果直接执行reconnect 会触发onclose导致重连两次
                        console.log("由于长时间未操作，连接断开 请重新登录")
                        var message = new proto.Model();
                        message.setMsgtype(1)
                        message.setCmd(1)
                        message.setToken(2)
                        message.setSender("2")
                        ws.send(message.serializeBinary());
                        ws.close()
                    }, self.timeout)
                }, this.timeout)
            }
        }

        function sendMsg(msg) { //发送消息
            if (window.WebSocket) {
                if (ws.readyState == WebSocket.OPEN) { //如果WebSocket是打开状态
                    var message = {}
                    message["msgtype"] = 0;
                    message["cmd"] = 4;
                    message["sender"] = userpkey;       // 发送人
                    message["receiver"] = selectfriend;     // 接收人
                    var contentBoby = {}
                    contentBoby["content"] = msg
                    contentBoby["type"] = 0
                    message["content"] = JSON.stringify(contentBoby);     // 请求数据
                    ws.send(JSON.stringify(message)); //send()发送消息
                    heartCheck.reset().start();       //如果发送消息成功，心跳检测重置
                    return;
                } else {
                    console.log("发送失败")
                    // 跳转登录页
                }
            }
            console.log("发送失败")
        }
    </script>
</head>
<body>

<form id="form" onsubmit="return false">
    <div>
        <h3>好友列表</h3>
        <input type="button" onclick="loaduserinfo()" value="刷新好友列表"/><br>
        <div style="border:1px solid  #000;width: 600px" id="friendlists">

        </div>
    </div>
    <div>
        <spen>选择的好友聊天是：</spen>
        <div id="onlyfriend">
            <div>暂时没有选中好友聊天对象</div>
        </div>
    </div>
    <div id="dic" name="div" style="width: 400px">

    </div>
    <input id="btn1" onclick="sendmessage()" type="button" value="发送"><br>
    <h3>信息</h3>
    <div style="border:1px solid  #000;width: 600px" id="msg">
    </div>
    <input type="button" value="清空" onclick="javascript:document.getElementById('msg').value = ''"/>
    <input type="button" value="获取消息列表"/><br>
    <input type="button" onclick="onfindmsglist()" value="获取用户列表"/><br>
    <div id="duserlist">

    </div>
    <h3>待添加的好友列表</h3>
    <div style="border:1px solid  #000;width: 600px" id="
"></div>
    <div>
        <h3>好友申请列表 </h3>
        <div id="getfriendlistdiv"></div>
    </div>
    <input type="button" onclick="getapplyfriend()" value="获取好友申请列表"/><br>
</form>
</body>
<script>
    var E = window.wangEditor;
    var editor = new E('#dic');
    editor.customConfig.uploadImgShowBase64 = true   // 使用 base64 保存图片
    editor.create();
    var datainfo = {} // 初始化信息
    var selectfriend = -1  // 选择聊天的好友 id
    // 获取用户信息
    function loaduserinfo(){
        var content={}
        content["userid"]=userpkey
        sendhttpMsg(userpkey,"init",content)
    }

    // 加载好友列表
    function loadfriendlist(data) {
            $("#friendlists").empty();
              data.list.forEach(group => {
                     $("#friendlists").append("<div id='groupid" + group.id + "' groupid='" + group.id + "' >" + group.name + "(" + group.list.length + ")" + "</div>")
                     group.list.forEach(user => {
                           $("#groupid"+group.id).append("<button onclick='selectfriendfunction(" + user.id + ",\"" + user.username + "\")'>好友状态:" + user.status + "好友名称" + user.username + "</button>")
                     })
             })
    }
    //加载好友申请列表 请求
    function getapplyfriend(){
        var content={}
        content["userid"]=userpkey
        sendhttpMsg(userpkey,"getapplyfriendlist",content)
    }
    //加载好友申请列表 结果
    function getapplyfriendResult(data){
        $("#getfriendlistdiv").empty();
                 data.forEach(applyfreind=>{
                     console.log("applyfreind");
                     console.log(applyfreind);
                     $("#getfriendlistdiv").append("<div ><span>好友申请时间:"+applyfreind.createtime+">>>好友申请人名称:"+applyfreind.fromusername+"好友附言:"+applyfreind.postscript
                                 +"申请状态:"+applyfreind.status+"</span><button onclick='dealapplyfriend("
                         +applyfreind.id+",1)'>同意</button><button onclick='dealapplyfriend("
                         +applyfreind.id+",2)'>不同意</button></div>")
         })
    }

    // 修改好友申请状态
    function dealapplyfriend(id, status) {
        //这里附言 和对应分组 省略  实现重构页面时需重写
        var content={}
        content["applyuserid"]=id
        content["state"]=status
        content["reply"]=""
        content["groupid"]=datainfo.list[0].id
        sendhttpMsg(userpkey,"updApplyUser",content)
    }

    function selectfriendfunction(id, name) {
        selectfriend = id
        console.log("选中的聊天ID：" + id)
        $("#onlyfriend").empty()
        $("#onlyfriend").append("<span>" + name + " </span>")
        finduserstate(id)
    }

    //查询对应所选中的好友 对应未阅读的剩余信息
    function finduserstate() {
        var content={}
        content["formuserid"]=userpkey
        content["touserid"]=selectfriend
        sendhttpMsg(userpkey,"findUserRead",content)
    }
    function finduserstateResult(data) {
        console.log("finduserstate读取选中好友对应未读取的好友信息:")
        console.log(data)
        data.forEach(content => {
            $("#msg").append("<div> 选中后加载的消息内容:" + content.content + ">>发送时间:" + content.created + "来自id:" + content.fromId +"</div>")})
    }
    // 显示用户好友聊天列表
    function  findUseridRecordCustomlist(data){
        console.log("显示用户好友聊天列表")
        console.log(data.items)
        data.items.forEach(content => {
            $("#msg").append("<div> 消息内容:" + content.content + ">>发送时间:" + content.created + "来自id:" + content.fromId + "还有"+content.noreadcount+ "条信息未读取</div>")}
            )
    }
    // 公共的获取后端方法  但是返回结果不是这里
    function sendhttpMsg(receiver, url,msg) { // 请求后台 参数1  请求人 后台发送会前端的接受人   参数2 请求方法的方法名称  参数3 对应的请求参数
        if (window.WebSocket) {
            if (ws.readyState == WebSocket.OPEN) { //如果WebSocket是打开状态
                var message = {}
                message["msgtype"] = 0;
                message["cmd"] = 6;
                message["url"] = url;
                message["receiver"] = receiver;     // 接收人
                message["content"] = JSON.stringify(msg);     // 请求数据
                ws.send(JSON.stringify(message)); //send()发送消息
                heartCheck.reset().start();       //如果发送消息成功，心跳检测重置
                return;
            } else {
                console.log("发送请求失败")
                // 跳转登录页
            }
        }
        console.log("发送失败")
    }
    // 获取当前除用户本身之外的用户列表  请求
    function onfindmsglist() {
        var content={}
          content["userid"]=userpkey
        sendhttpMsg(userpkey,"getuserlist",content)
    }
    // 获取当前除用户本身之外的用户列表  返回结果
    function onfindmsglistResult(data){
        $("#duserlist").empty();
        data.forEach(user => {
            $("#duserlist").append("<button onclick='addfriends(" + user.id + ")'>" + user.username + "</button>")
         })
    }
    function publicResulthandle(data){
        if(data.code==200){
            return data.data;
        }else{
            console.log("code:"+data.code)
            console.log("msg:"+data.msg)
            alert(data.msg)
            return null;
        }
    }
    function publicResulthandlevoid(data){
        if(data.code==200){
            return data.msg;
        }else{
            console.log("code:"+data.code)
            console.log("msg:"+data.msg)
            alert(data.msg)
            return null;
        }
    }

    // 添加好友进入申请列表
    function addfriends(id) {
        var content={}
        content["formId"]=userpkey
        content["touserId"]=id
        content["groupiden"]=datainfo.list[0].id
        content["type"]=1
        content["postscript"]= ""
        sendhttpMsg(userpkey,"getfriedns",content)
    }

    // 发送信息 获取富文本中输入的内容
    function sendmessage() {
        if(selectfriend==-1){
            alert("发送消息失败，请先选中对应要发送的人")
        }else{
            var dic = editor;
            sendMsg(dic.txt.html())
            editor.txt.clear()
        }
    }
</script>
</html>